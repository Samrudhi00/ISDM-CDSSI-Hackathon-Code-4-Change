# -*- coding: utf-8 -*-
"""Algorithm_CodeForChange.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m5iTpkplGDt1z5HGvcs22bvuVAdwA_Jf

# **Predicting financial vulnerability of women-headed households in rural India**
# Develop an accurate model for predicting financial risk in these households.
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import OneHotEncoder

df = pd.read_csv("/content/eda_PRICE_dataset.csv")

print(df)

num_rows, num_cols = df.shape
print("Number of rows:", num_rows)
print("Number of columns:", num_cols)

"""# **Introduce a financial vulnerability index for Indian women-led households.**"""

# prompt: save Financial_Vulnerability_Index column in eda_PRICE_dataset.csv
df.to_csv("eda_PRICE_dataset.csv")

df['Financial_Vulnerability_Index'] = np.where(df['Financial_Vulnerability'] <= 0, 'Yes', 'No')

print(df)

num_rows, num_cols = df.shape
print("Number of rows:", num_rows)
print("Number of columns:", num_cols)

df['Financial_Vulnerability_Index'].value_counts()

plt.figure(figsize=(10,5))
sns.countplot(x='Financial_Vulnerability_Index', data=df)
plt.xlabel('Financial_Vulnerability')
plt.ylabel('Count')
plt.show()

selected_columns = [
    'States',
    'Age',
    'Marital Status',
    'Education Level',
    'Primary Occupation',
    'Number of Members',
    'Number of Earners',
    'Do you have Mobile?',
    'Type of Mobile',
    'Do you have Bank Acc?',
    'Saving',
    'Yojana',
    'AccountType',
    'Total routine Expenditure',
    'Financial_Vulnerability_Index'
]

df = df[selected_columns]

# Check for missing values
print(df.isnull().sum())
# Handle missing values as needed

# One-hot encode categorical variables
df_encoded = pd.get_dummies(df, drop_first=True)

df_encoded.columns

X = df_encoded.drop('Financial_Vulnerability_Index_Yes', axis=1)
Y = df_encoded['Financial_Vulnerability_Index_Yes']

from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

"""# **RandomForestClassifier**"""

from sklearn.ensemble import RandomForestClassifier

# Initialize the Random Forest classifier
clf = RandomForestClassifier(random_state=42)

# Train the classifier on the training data
clf.fit(X_train, Y_train)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
# Make predictions on the test data
y_pred = clf.predict(X_test)

# Evaluate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy:.2f}")

# Generate classification report
print("Classification Report:")
print(classification_report(y_test, y_pred))

# Visualize confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()

"""# **Logistic Regression**"""

from sklearn.linear_model import LogisticRegression
# Initialize logistic regression model
Logistic_model = LogisticRegression(random_state=42)

# Train the model on the training data
Logistic_model.fit(X_train, Y_train)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
# Make predictions on the test data
y_pred = Logistic_model.predict(X_test)

# Evaluate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy:.2f}")

# Generate classification report
print("Classification Report:")
print(classification_report(y_test, y_pred))

# Visualize confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()

"""# **Naive Bayes Classifier-MultinomialNB**"""

from sklearn.naive_bayes import MultinomialNB
# Initialize the Naive Bayes model
MultinomialNBmodel = MultinomialNB()

# Train the model
MultinomialNBmodel.fit(X_train, Y_train)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
# Make predictions on the test data
y_pred = MultinomialNBmodel.predict(X_test)

# Evaluate accuracy
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy:.2f}")

# Generate classification report
print("Classification Report:")
print(classification_report(y_test, y_pred))

# Visualize confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()

"""# **Support Vector Machines (SVM)**"""

from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.svm import SVC

# Identify numerical columns
numerical_features = [cname for cname in X.columns if X[cname].dtype in ['int64', 'float64']]

# Identify categorical columns (assuming they are of type 'object')
categorical_features = [cname for cname in X.columns if X[cname].dtype == "object"]

# Preprocessing for numerical data
numerical_transformer = StandardScaler()

# Preprocessing for categorical data
categorical_transformer = OneHotEncoder(handle_unknown='ignore')

# Bundle preprocessing for numerical and categorical data
preprocessor = ColumnTransformer(
    transformers=[
        ('num', numerical_transformer, numerical_features),
        ('cat', categorical_transformer, categorical_features)
    ])

# Define the model
model = SVC(kernel='linear')  # Use 'rbf' for non-linear problems

# Bundle preprocessing and modeling code in a pipeline
clf = Pipeline(steps=[('preprocessor', preprocessor),
                      ('model', model)
                     ])

# Training the SVM model
clf.fit(X_train, Y_train)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
# Predicting the test results
y_pred = clf.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy:.2f}")
print(classification_report(y_test, y_pred))

# Making the Confusion Matrix
cm = confusion_matrix(y_test, y_pred)

# Visualize confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.show()

def predict_financial_vulnerability(input_data):
    """
    Function to predict the Financial Vulnerability Index for input data.

    Parameters:
    input_data (dict): Input data dictionary containing values for the selected features.

    Returns:
    str: Predicted Financial Vulnerability Index ('YES' or 'NO').
    """

    # Convert input data into a DataFrame
    input_df = pd.DataFrame([input_data])

    # Preprocess the input data (similar to how you preprocessed your training data)
    input_encoded = pd.get_dummies(input_df, drop_first=True)  # One-hot encode categorical variables if needed

    # Ensure input DataFrame has the same columns as the training data
    input_features = input_encoded.reindex(columns=X.columns, fill_value=0)

    # Make prediction using the pre-trained model
    prediction = clf.predict(input_features)

    # Map the predicted label to the corresponding Financial Vulnerability Index value
    if prediction[0] == 1:
        return 'YES'
    else:
        return 'NO'

"""# **WE HAVE FINALLY DECIDED TO USE RANDOM FOREST ALGORITHM AS IT HAVE HIGHEST ACCURACY**"""

# Example usage of the prediction function
input_data = {
    'States': 'CHHATTISGARH',
    'Age': 34,
    'Marital Status': 'Unmarried',
    'Education Level': 'Middle',
    'Primary Occupation': 'Self-employed - Agriculture',
    'Number of Members': 6,
    'Number of Earners': 2,
    'Do you have Mobile?': 'No',
    'Type of Mobile': None,
    'Do you have Bank Acc?': 'No',
    'Saving': 10000,
    'Yojana': 0,
    'AccountType': 0,
    'Total routine Expenditure': 80000,
}

predicted_index = predict_financial_vulnerability(input_data)
print("Predicted Financial Vulnerability Index:", predicted_index)

# Calculate count of 'YES' and 'NO' values by state
state_counts = df['Financial_Vulnerability_Index'].groupby(df['States']).value_counts().unstack().fillna(0)

# Plotting the bar graph
fig, ax = plt.subplots(figsize=(10, 8))
state_counts.plot(kind='bar', stacked=True, ax=ax, color=['skyblue', 'salmon'])

# Adding labels and title
ax.set_title('Financial Vulnerability Index (YES/NO) by State', fontsize=15)
ax.set_xlabel('State', fontsize=12)
ax.set_ylabel('Count', fontsize=12)
ax.legend(title='Financial Vulnerability Index')

# Show plot
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.tight_layout()  # Adjust layout to prevent overlapping labels
plt.show()

